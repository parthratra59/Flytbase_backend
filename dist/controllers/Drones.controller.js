var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import ApiError from "../utils/apiError";
import { Drone } from "../models/Drones.model";
import { User } from "../models/User.model";
import { Sites } from "../models/Site.model";
import ApiResponse from "../utils/apiResponse";
export const addDrone = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        const { drone_id, drone_type, make_name, name, siteID } = req.body;
        if (!drone_id || !drone_type || !make_name || !name || !siteID) {
            res
                .status(400)
                .json(new ApiError(400, "All fields are required and drone_id,drone_type,make_name,name should be unique"));
        }
        // Check if a drone with the same unique fields already exists
        const existingDrone = yield Drone.findOne({ drone_id });
        if (existingDrone) {
            return res
                .status(400)
                .json(new ApiError(400, "Drone with the same ID already exists"));
        }
        // Check if the provided siteID exists in the Sites model
        const existingSite = yield Sites.findById({ _id: siteID });
        if (!existingSite) {
            throw new ApiError(404, "Site not found with the given ID");
        }
        // now we use the .save method to save the drone information to the database
        const newdrone = new Drone({
            drone_id,
            drone_type,
            make_name,
            name,
            siteID,
            user_id: (_a = req.insertprop) === null || _a === void 0 ? void 0 : _a._id,
        });
        yield newdrone.save();
        // we do this thing also $push :{
        //  drones:drone_id
        // }
        // but there could be the chanches of duplicate
        yield User.findByIdAndUpdate({
            _id: (_b = req.insertprop) === null || _b === void 0 ? void 0 : _b._id, // match the _id with the middleware id
        }, { $addToSet: { drones: newdrone._id } }, // Add drone_id to drones array if not already present and Use $addToSet to prevent duplicates
        { new: true });
        yield Sites.findByIdAndUpdate({
            _id: siteID, // match the _id with the provided siteID
        }, { $addToSet: { drones: newdrone._id } }, // Use $addToSet to prevent duplicates
        { new: true });
        res
            .status(201)
            .json(new ApiResponse(201, newdrone, "Drones created successfully"));
    }
    catch (err) {
        console.error("Error adding drone:", err);
        res.status(500).json(new ApiError(500, "Failed to create Drone"));
    }
});
export const updateDronebyID = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    try {
        // we can't use drone_id here because it is a string and in params we need a ObjectId
        // we can store also objectId in the starting drone_id but in ObjectId we need 24 24-character hexadecimal string
        // we we take ObjectId as the ObjectId in the DroneModel so we are using (_id) which is
        // autogenerated at the time of Model creation
        const { _id } = req.params;
        const updateData = req.body;
        if (updateData.siteID || updateData.user_id || updateData.drone_id) {
            return res
                .status(403)
                .json(new ApiError(403, "You are not allowed to update drone_id, user_id or siteID"));
        }
        const updatedDrone = yield Drone.findByIdAndUpdate({
            _id,
            // user_id is same ObjectId which was generated by mongoDB at the time model creation
            user_id: (_a = req.insertprop) === null || _a === void 0 ? void 0 : _a._id,
        }, {
            $set: updateData,
        }, {
            new: true,
        });
        if (!updatedDrone) {
            throw new ApiError(404, "Drone not found");
        }
        res
            .status(200)
            .json(new ApiResponse(200, updatedDrone, "Drone updated successfully"));
    }
    catch (error) {
        res.status(500).json(new ApiError(500, "Failed to get all drones"));
    }
});
export const DeleteDroneById = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        const { _id } = req.params;
        // Find and delete the drone from the Drone model
        const deletedDrone = yield Drone.findByIdAndDelete(_id, {
            $set: {
                deleted_by: (_a = req.insertprop) === null || _a === void 0 ? void 0 : _a._id,
                deleted_on: new Date(),
            },
        });
        if (!deletedDrone) {
            return res.status(404).json(new ApiError(404, "Drone not found"));
        }
        // Remove the drone reference from the user's drones array
        yield User.updateOne({
            _id: (_b = req.insertprop) === null || _b === void 0 ? void 0 : _b._id,
        }, {
            $pull: { drones: deletedDrone._id }, // Remove object _id of drone from drones array which are provided by the Drone mongoDB model
        });
        yield Sites.updateOne({
            _id: deletedDrone.siteID,
        }, {
            $pull: { drones: deletedDrone._id }, // Remove object _id of drone from drones array which are provided by the Drone mongoDB model
        }, {
            new: true,
        });
        return res
            .status(200)
            .json(new ApiResponse(200, {}, "Drone deleted successfully"));
    }
    catch (error) {
        res.status(500).json(new ApiError(500, "Failed to delete Drone"));
    }
});
// get all Drones there is no need of id which is coming form the middleware
export const getAllDrones = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const drones = yield Drone.find();
        if (!drones) {
            return res.status(404).json(new ApiError(404, "No drones found"));
        }
        res.status(200).json(new ApiResponse(200, drones, "All drones retrieved"));
    }
    catch (error) {
        res.status(500).json(new ApiError(500, "Failed to get all drones"));
    }
});
// move site of drone
export const moveSiteofDrone = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    try {
        const { dID } = req.params;
        const { newSiteID } = req.body;
        if (!newSiteID) {
            return res.status(400).json(new ApiError(400, "newSiteID are required"));
        }
        const drone = yield Drone.findById(dID);
        if (!drone) {
            return res.status(404).json(new ApiError(404, "Drone not found"));
        }
        // Find the new site
        const newSite = yield Sites.findById(newSiteID);
        if (!newSite) {
            return res.status(404).json(new ApiError(404, "New site not found"));
        }
        const updatedDrone = yield Drone.findByIdAndUpdate({
            _id: dID,
            user_id: (_a = req.insertprop) === null || _a === void 0 ? void 0 : _a._id, // btw no need to pass this
        }, {
            $set: {
                siteID: newSiteID,
            },
        }, {
            new: true,
        });
        if (!updatedDrone) {
            return res.status(404).json(new ApiError(404, "Failed to update drone"));
        }
        // add drone to new site array
        yield Sites.findByIdAndUpdate({
            _id: newSiteID,
        }, {
            $addToSet: { drones: updatedDrone._id },
        }, {
            new: true,
        });
        // Remove drone from old site's drones array if the drone was previously in another site
        //   Comparing ObjectId objects: Directly comparing two ObjectId objects using === or !== may not work as expected because the comparison checks for reference equality rather than value equality.
        //   String representation: Converting ObjectId objects to their string representations using toString() allows you to compare their values correctly.
        if (drone.siteID && drone.siteID.toString() !== newSiteID.toString()) {
            yield Sites.findByIdAndUpdate({
                _id: drone.siteID,
            }, {
                $pull: { drones: updatedDrone._id },
            });
        }
        res
            .status(200)
            .json(new ApiResponse(200, updatedDrone, "Drone site moved successfully"));
    }
    catch (error) {
        res.status(500).json(new ApiError(500, "Failed to move drone site"));
    }
});
